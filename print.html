<!DOCTYPE HTML>
<html lang="En" class="sidebar-visible no-js navy">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Paraphrasing the Pdfs</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous">
        
        <link rel="stylesheet" href="css/tavianator.css">
        
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js" integrity="sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp" crossorigin="anonymous"></script>
        
        <script src="tavianator.js"></script>
        
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-EBDQXGZ6R1"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-EBDQXGZ6R1');
        </script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./theme/tabbed-code-blocks.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> INTRODUCTION</a></li><li class="chapter-item expanded "><a href="mediacal_summilation.html"><strong aria-hidden="true">2.</strong> medical_similation</a></li><li class="chapter-item expanded "><a href="sim_medical.html"><strong aria-hidden="true">3.</strong> medical similation</a></li><li class="chapter-item expanded "><a href="1-2023-10-02-14_21.html"><strong aria-hidden="true">4.</strong> 1</a></li><li class="chapter-item expanded "><a href="1-e2.html"><strong aria-hidden="true">5.</strong> 1</a></li><li class="chapter-item expanded "><a href="1-e3.html"><strong aria-hidden="true">6.</strong> 1</a></li><li class="chapter-item expanded "><a href="1-e5.html"><strong aria-hidden="true">7.</strong> 1</a></li><li class="chapter-item expanded "><a href="1-e8.html"><strong aria-hidden="true">8.</strong> 8</a></li><li class="chapter-item expanded "><a href=".md.html"><strong aria-hidden="true">9.</strong> </a></li><li class="chapter-item expanded "><a href="2.html"><strong aria-hidden="true">10.</strong> 2</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Paraphrasing the Pdfs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ayoubelmhamdi/pdfgpt" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>Simplification using LLM</p>
<ul>
<li><a href="./README.html">INTRODUCTION</a></li>
<li><a href="./mediacal_summilation.html">medical_similation</a></li>
<li><a href="./sim_medical.html">medical similation</a></li>
<li><a href="./1-2023-10-02-14_21.html">1</a></li>
<li><a href="./1-e2.html">1</a></li>
<li><a href="./1-e3.html">1</a></li>
<li><a href="./1-e5.html">1</a></li>
<li><a href="./1-e8.html">8</a></li>
<li><a href=".html"></a></li>
<li><a href="2.html">2</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="université-moulay-ismail"><a class="header" href="#université-moulay-ismail">Université Moulay Ismail</a></h1>
<h2 id="faculté-des-sciences"><a class="header" href="#faculté-des-sciences">Faculté des Sciences</a></h2>
<h3 id="mémoire-du-projet-de-fin-detudes"><a class="header" href="#mémoire-du-projet-de-fin-detudes">Mémoire du Projet de Fin d’Etudes</a></h3>
<p>Ce mémoire a été réalisé par Abdelmajid ES-SAADI dans le cadre de l'obtention du diplôme de Master Spécialisé en Techniques de Rayonnements en Physique Médicale (TRPM). Le projet porte sur les différentes applications en oncologie des méthodes de simulation par Monte Carlo.</p>
<p>Le mémoire a été soutenu le 23 septembre 2028 devant un jury composé des professeurs Ismail ESSAOUDI, Zouhir EL AMRAOUIL, Rajae SBIHI et Mohammed KHALIS.</p>
<p>Remerciements:</p>
<ul>
<li>Nous remercions DIEU pour nous avoir donné la force et la volonté de réaliser ce travail.</li>
<li>Nous remercions l'organisme de la faculté des sciences de Meknès pour nous avoir offert cette formation.</li>
<li>Nous remercions particulièrement notre encadrant, le Pr. Mohammed Khalis, pour son aide, sa patience et ses conseils pertinents.</li>
<li>Nous remercions également l'équipe de recherche de l'Agence d'Energie Atomique Japonaise pour nous avoir fourni la licence du code PHITS.</li>
<li>Nous remercions nos enseignants au Master en Techniques de Rayonnement en Physique Médicale de la faculté des sciences de Meknès pour leur contribution à notre formation.</li>
<li>Nous remercions nos collègues et nos familles pour leur soutien moral.</li>
</ul>
<p>Table des matières:</p>
<ul>
<li>Introduction générale</li>
<li>Chapitre 1: Notions physiques en oncologie</li>
<li>Chapitre 2: Généralités sur la méthode de Monte Carlo</li>
<li>Chapitre 3: Codes de simulations par Monte Carlo</li>
<li>Chapitre 4: Simulation de transport des particules par Monte Carlo</li>
<li>Chapitre 5: Simulation par le code PHITS</li>
<li>Chapitre 6: Résultats et discussions</li>
<li>Conclusion générale</li>
<li>Références</li>
</ul>
<p>Dans le chapitre 1, nous abordons les notions physiques en oncologie, notamment la radiothérapie et la hadronthérapie. Nous expliquons les différentes interactions des photons et des ions avec la matière.</p>
<p>Le chapitre 2 présente les généralités sur la méthode de Monte Carlo, y compris les générateurs de nombres aléatoires et les méthodes d'échantillonnage.</p>
<p>Le chapitre 3 traite des codes de simulations par Monte Carlo, tels que Penelope, EGS, MCNP, PHITS et GEANT4.</p>
<p>Le chapitre 4 se concentre sur la simulation de transport des particules par Monte Carlo, en expliquant la géométrie, la génération des particules et les algorithmes de transport.</p>
<p>Le chapitre 5 décrit la simulation par le code PHITS, en détaillant la structure du fichier d'entrée et les modèles physiques utilisés.</p>
<p>Le chapitre 6 présente les résultats et les discussions obtenus à partir des simulations réalisées.</p>
<p>En conclusion, nous résumons les principales conclusions de notre travail.</p>
<p>Ce mémoire est accompagné d'une liste de références utilisées pour approfondir les sujets abordés.</p>
<h1 id="universite-moulay-ismail-faculte-des-sciences"><a class="header" href="#universite-moulay-ismail-faculte-des-sciences">UNIVERSITE MOULAY ISMAIL FACULTE DES SCIENCES</a></h1>
<h2 id="es--somme-des-énergies-par-unité-de-longueur-des-particules-sortantes-électrons-du-volume-considéré"><a class="header" href="#es--somme-des-énergies-par-unité-de-longueur-des-particules-sortantes-électrons-du-volume-considéré">Es : somme des énergies par unité de longueur des particules sortantes (électrons) du volume considéré.</a></h2>
<p>Nous considérons un petit rayon r du cylindre, et donc le TEL ne prend pas en compte les électrons secondaires qui vont déposer leur énergie en dehors du cylindre. En bas, le cylindre possède un rayon assez élevé R, et donc nous pouvons faire l’approximation que TEL = αEe-</p>
<p><img src="https://example.com/image.png" alt="Schémas d’illustrations pour la prise en compte du calcul du TEL" /></p>
<p>Plus ce paramètre est grand, plus les dégâts biologiques aux tissus traversés sont importants.</p>
<h2 id="135-définition-de-la-dose"><a class="header" href="#135-définition-de-la-dose">1.3.5 Définition de la dose</a></h2>
<h3 id="dose-physique"><a class="header" href="#dose-physique">Dose physique</a></h3>
<p>La dose déposée ou dose absorbée par les tissus, notée D et exprimée en Gray (J/kg), représente l’énergie moyenne déposée par les particules ionisantes dans un volume de masse dm, et est donnée par la relation suivante :</p>
<p>dD = n</p>
<p>D’autre part, la dose est définie comme le produit de la fluence F et du pouvoir d’arrêt massique μ sous la forme :</p>
<p>D = F * μ</p>
<h3 id="dose-biologique"><a class="header" href="#dose-biologique">Dose biologique</a></h3>
<p>La dose biologique ou dose équivalente, notée Dy, est exprimée en Gray Équivalent Cobalt (60Co) et est définie par :</p>
<p>Dy = D * EBR</p>
<p>avec EBR : l’Efficacité Biologique Relative, sans unité. Pour les protons (protonthérapie), on utilise EBR = 1.1 quelles que soient les conditions de calcul. Cependant, EBR est entre 2 et 3 pour les ions de carbone (carbonethérapie).</p>
<h2 id="interaction-particule---matière-biologique"><a class="header" href="#interaction-particule---matière-biologique">Interaction particule - matière biologique</a></h2>
<p>L’interaction des particules ionisantes avec la matière biologique a pour effet d’endommager l’ADN directement ou indirectement par destruction de la molécule d’eau en deux radicaux libres actifs chimiquement qui attaquent la matière par des réactions chimiques. La figure 1.12 présente une illustration de cette interaction.</p>
<p><img src="https://example.com/image.png" alt="Séquence schématisée des effets biologiques" /></p>
<h2 id="14-conclusion"><a class="header" href="#14-conclusion">1.4 Conclusion</a></h2>
<p>Le traitement des tumeurs cancéreuses utilise des particules ionisantes, qui transportent de l’énergie aux tumeurs en déclenchant les processus d’ionisation des tissus cibles. La connaissance de ces processus de transport des particules utilisées est indispensable pour optimiser le traitement et minimiser le risque sur les tissus sains environnants.</p>
<h1 id="chapitre-2"><a class="header" href="#chapitre-2">CHAPITRE 2</a></h1>
<h2 id="gÉnÉralitÉs-sur-la-mÉthode-de-monte-carlo"><a class="header" href="#gÉnÉralitÉs-sur-la-mÉthode-de-monte-carlo">GÉNÉRALITÉS SUR LA MÉTHODE DE MONTE CARLO</a></h2>
<h3 id="21-introduction"><a class="header" href="#21-introduction">2.1 Introduction</a></h3>
<p>Les calculs de Monte Carlo font appel à une méthode statistique basée sur l'utilisation des nombres aléatoires comparables à ceux produits par les jeux de hasard dans les casinos. Dans ce contexte, on distingue deux grands domaines où la méthode de Monte Carlo peut être utilisée avec succès.</p>
<h3 id="problèmes-déterministes"><a class="header" href="#problèmes-déterministes">Problèmes déterministes</a></h3>
<p>Ce sont des problèmes de nature déterministe faisant appel aux calculs numériques, par exemple :</p>
<ul>
<li>Estimation des surfaces.</li>
<li>Calculs d’intégrales multiples.</li>
<li>Résolution d’équations différentielles.</li>
<li>Résolution de systèmes d’équations algébriques.</li>
<li>Résolution de problèmes d’optimisation combinatoire.</li>
</ul>
<h3 id="phénomènes-et-processus-aléatoires"><a class="header" href="#phénomènes-et-processus-aléatoires">Phénomènes et processus aléatoires</a></h3>
<ul>
<li>Mouvement de particules.</li>
<li>Systèmes stochastiques de gestion ou de production.</li>
<li>Reconnaissance de formes (analyse d’images, de paroles, ...).</li>
<li>Systèmes de commande décrits par des équations différentielles ordinaires ou des équations aux différences.</li>
</ul>
<h3 id="22-générateur-de-nombres-aléatoires"><a class="header" href="#22-générateur-de-nombres-aléatoires">2.2 Générateur de nombres aléatoires</a></h3>
<h4 id="221-principe"><a class="header" href="#221-principe">2.2.1 Principe</a></h4>
<p>La simulation Monte Carlo repose toujours sur un générateur de nombres aléatoires fiable. On appelle nombres aléatoires des variables aléatoires indépendantes uniformément distribuées sur l'intervalle [0,1].</p>
<h4 id="222-nombres-véritablement-aléatoires"><a class="header" href="#222-nombres-véritablement-aléatoires">2.2.2 Nombres véritablement aléatoires</a></h4>
<p>Les nombres vraiment aléatoires sont imprévisibles, ils ne sont pas générés par un processus déterministe et doivent être produits par un processus physique aléatoire, par exemple la désintégration radioactive, l'impact de la séparation des rayons cosmiques sur les détecteurs ou la synchronisation de la génération de bruit dans les circuits électroniques.</p>
<h4 id="223-nombres-pseudo-aléatoires"><a class="header" href="#223-nombres-pseudo-aléatoires">2.2.3 Nombres pseudo-aléatoires</a></h4>
<p>À l'aide d'un ordinateur, nous pouvons utiliser des nombres dits pseudo-aléatoires, qui sont générés par un algorithme conçu pour produire une séquence de nombres non corrélés et uniformément répartis dans un intervalle donné. Les chiffres semblent complètement aléatoires d’un point de vue extérieur, mais ils montrent un schéma récurrent.</p>
<p>En pratique, nous n’utilisons pas de vrais nombres aléatoires, désormais nous appellerons les nombres pseudo-aléatoires nombres aléatoires.</p>
<p>En général, un générateur de nombres aléatoires doit répondre aux conditions de base suivantes :</p>
<ul>
<li>La distribution des nombres aléatoires doit être uniformément répartie dans un intervalle spécifique, et doit répondre à des tests de cohérence et d’indépendance.</li>
<li>La séquence comporte un grand nombre de nombres uniques avant de répéter la boucle.</li>
<li>La génération de nombres aléatoires est très rapide.</li>
</ul>
<h3 id="23-les-méthodes-principales-déchantillonnage"><a class="header" href="#23-les-méthodes-principales-déchantillonnage">2.3 Les méthodes principales d’échantillonnage</a></h3>
<h4 id="231-principe"><a class="header" href="#231-principe">2.3.1 Principe</a></h4>
<p>La méthode de Monte Carlo (MC) consiste à échantillonner la distribution de probabilités décrivant un processus physique en utilisant des nombres aléatoires. Il existe trois méthodes principales d’échantillonnage : la méthode d’inversion directe, la méthode de réjection et la méthode de composition.</p>
<h4 id="232-la-méthode-dinversion-directe"><a class="header" href="#232-la-méthode-dinversion-directe">2.3.2 La méthode d’inversion directe</a></h4>
<p>Nous utilisons la méthode d’inversion directe lorsque la fonction de répartition de la variable aléatoire, qui renvoie la probabilité de prendre une valeur inférieure ou égale à a, peut être inversée. Puisque y = F(x) est uniformément distribué entre 0 (la probabilité que la variable aléatoire ne prenne aucune valeur) et 1 (la probabilité que la variable aléatoire prenne n’importe quelle valeur), la variable x = F^(-1)(y) obéit à la fonction de distribution p(x) = F'(x). Il suffit donc de générer une suite de valeurs R uniformément réparties entre 0 et 1, puis d’utiliser x = F^(-1)(R) pour obtenir les valeurs selon p(x).</p>
<p>Par exemple, la profondeur d’interaction des rayons gamma pénétrant dans un matériau d’épaisseur d et de coefficient d’atténuation μ est une variable aléatoire caractérisée par la fonction de partition :</p>
<p>La relation entre F(x) et p(x) est donnée par :</p>
<p>Avec μ un paramètre. La fonction de distribution est alors :</p>
<p>Si R est uniformément distribué dans l'intervalle [0, 1], alors la variable</p>
<p>sera automatiquement distribuée selon p(x).</p>
<p>La probabilité que la variable x soit supérieure à d est la probabilité que le rayon gamma n’interagisse pas dans le matériau. Elle est égale à :</p>
<p>Il détermine ainsi la proportion d’impacts qui n’entraînent pas d’interactions d’épaisseur de matériau et caractérise en quelque sorte l’inefficacité du processus de simulation pour cette tâche.</p>
<h4 id="233-la-méthode-de-réjection"><a class="header" href="#233-la-méthode-de-réjection">2.3.3 La méthode de réjection</a></h4>
<p>Une autre méthode d’échantillonnage a été proposée par Von Neumann. Elle consiste à tirer uniformément une variable aléatoire R dans l'intervalle [0,1] d’une distribution (autre que p(x)) et à la tester au hasard pour déterminer si elle est acceptée ou rejetée. Ces méthodes de rejet conduisent à une technique très générale d’échantillonnage à partir de n’importe quelle fonction de densité de probabilité (PDF) et à déterminer sa valeur correspondante en utilisant la règle d’échelle affine :</p>
<p>dans le domaine variable D = [Xmin, Xmax] d’une variable aléatoire. La valeur de x pour le deuxième graphe est affectée en fonction de p(x), tandis que le deuxième graphe R’ est uniformément réparti entre 0 et 1.</p>
<p>Cela permet de conserver x si R0 est inférieur ou égal à f(x) = p(x), et si non on le rejette.</p>
<h4 id="234-la-méthode-de-composition"><a class="header" href="#234-la-méthode-de-composition">2.3.4 La méthode de composition</a></h4>
<p>Si les deux méthodes précédentes ne sont pas applicables, une méthode combinant les deux peut être utilisée.</p>
<p>Soit deux fonctions de densités de probabilités normalisées à 1 : f(x) et g(x) définies par la relation suivante :</p>
<p>On utilise alors la méthode directe pour sélectionner x en utilisant f(x) comme fonction de densité de probabilité normalisée. Ensuite, on applique la méthode de rejet sur la fonction g(x).</p>
<h3 id="24-précision-dun-code-monte-carlo"><a class="header" href="#24-précision-dun-code-monte-carlo">2.4 Précision d’un code Monte Carlo</a></h3>
<h4 id="241-incertitudes-physiques"><a class="header" href="#241-incertitudes-physiques">2.4.1 Incertitudes physiques</a></h4>
<p>Quelle que soit la précision des données physiques utilisées dans un code de Monte Carlo, la qualité des résultats est inévitablement limitée par le modèle de diffusion utilisé. La manière dont les sections efficaces sont tabulées, interpolées et échantillonnées peut introduire des erreurs supplémentaires.</p>
<h4 id="242-incertitudes-statistiques"><a class="header" href="#242-incertitudes-statistiques">2.4.2 Incertitudes statistiques</a></h4>
<p>Les résultats des calculs de Monte Carlo sont également soumis à une incertitude statistique. Pour éviter les fluctuations statistiques, un certain nombre de particules (des centaines à des milliards de particules) doivent être simulées.</p>
<p>En effet, plus le nombre d’histoires N généré est important, plus l’incertitude associée à la grandeur calculée dans le volume d’intérêt sera petite, et plus le résultat estimé par MC est proche de la réalité. L’incertitude statistique associée à σ correspondant à l’écart-type sur la moyenne G, est déterminée à partir de la relation suivante :</p>
<p>Où :</p>
<ul>
<li>σ : est l'incertitude statistique associée à la moyenne G.</li>
<li>N : est la taille de l’échantillon, c’est-à-dire le nombre de valeurs dans l’échantillon.</li>
<li>gj : représente les valeurs individuelles dans l’échantillon.</li>
<li>G : est la moyenne des valeurs dans l’échantillon.</li>
</ul>
<p>Ce type d’incertitude est lié aux modèles physiques utilisés pour déterminer la section efficace et le pouvoir d’arrêt. Ainsi, il est affecté par les erreurs de programmation.</p>
<h3 id="25-efficacité-dune-simulation-monte-carlo"><a class="header" href="#25-efficacité-dune-simulation-monte-carlo">2.5 Efficacité d’une simulation Monte Carlo</a></h3>
<p>L’efficacité ε d’une simulation permet de comparer les performances de deux méthodes de simulation. L’efficacité est définie par la relation :</p>
<p>Où ΔY est l’incertitude de l’estimation, ΔT est le temps de calcul et G est la moyenne.</p>
<p>L’efficacité d’un code de Monte Carlo dépend en grande partie de la qualité de son générateur de nombres aléatoires.</p>
<h3 id="26-estimation-de-la-valeur-π-par-monte-carlo"><a class="header" href="#26-estimation-de-la-valeur-π-par-monte-carlo">2.6 Estimation de la valeur π par Monte Carlo</a></h3>
<p>La méthode de Monte Carlo permet la résolution de certains problèmes numériques déterministes. Elle résout les problèmes de façon approchée avec une simulation.</p>
<p>Dans ce paragraphe, nous présentons brièvement l’approximation du nombre π par l’estimation de la surface d’un quart de disque de forme circulaire de rayon 1.</p>
<h4 id="261-algorithme"><a class="header" href="#261-algorithme">2.6.1 Algorithme</a></h4>
<p>Dans ce cas, on tire au hasard des coordonnées x et y, chacune dans l'intervalle [0, 1[. Si x^2 + y^2 &lt; 1, alors le point P de coordonnées (x,y) appartient au quart de disque D de centre (0,0) et de rayon 1. La probabilité que count_inside appartienne à D est 7/4 (rapport de l'aire de D et du carré l'englobant). Donc, si on tire au hasard num_points points, et si count_inside d'entre eux appartiennent à D, on obtient une approximation de π/4 égale à :</p>
<p>π/4 ≈ count_inside / num_points</p>
<h4 id="262-code-de-simulation"><a class="header" href="#262-code-de-simulation">2.6.2 Code de simulation</a></h4>
<pre><code class="language-python">import random
import matplotlib.pyplot as plt

num_points = 1000000
count_inside = 0

for _ in range(num_points):
    x = random.uniform(0, 1)
    y = random.uniform(0, 1)
    if x**2 + y**2 &lt; 1:
        count_inside += 1

pi_approx = 4 * count_inside / num_points

print(&quot;Approximation de pi :&quot;, pi_approx)

plt.figure(figsize=(5, 5))
plt.scatter(x_inside, y_inside, color='red', s=1)
plt.scatter(x_outside, y_outside, color='blue', s=1)
plt.show()
</code></pre>
<p>Ce code utilise la méthode de Monte Carlo pour estimer la valeur de π en approximant la surface d'un quart de disque de rayon 1. Il génère un grand nombre de points aléatoires dans un carré de côté 1 et compte combien de ces points se trouvent à l'intérieur du quart de disque. L'approximation de π est ensuite calculée en utilisant la formule π/4 ≈ count_inside / num_points. Le code affiche également un graphique des points générés, avec les points à l'intérieur du quart de disque en rouge et les points à l'extérieur en bleu.</p>
<h1 id="nombre-de-points-à-utiliser-pour-lestimation"><a class="header" href="#nombre-de-points-à-utiliser-pour-lestimation">Nombre de points à utiliser pour l'estimation</a></h1>
<p>num_points = 10000</p>
<h1 id="compteur-pour-les-points-dans-le-cercle"><a class="header" href="#compteur-pour-les-points-dans-le-cercle">Compteur pour les points dans le cercle</a></h1>
<p>count_inside = 0</p>
<h1 id="listes-pour-stocker-les-coordonnées-des-points-dans-et-hors-du-cercle"><a class="header" href="#listes-pour-stocker-les-coordonnées-des-points-dans-et-hors-du-cercle">Listes pour stocker les coordonnées des points dans et hors du cercle</a></h1>
<p>x_inside = []
y_inside = []
x_outside = []
y_outside = []</p>
<h2 id="chapitre-2-gÉnÉralitÉs-sur-la-mÉthode-de-monte-carlo"><a class="header" href="#chapitre-2-gÉnÉralitÉs-sur-la-mÉthode-de-monte-carlo">CHAPITRE 2. GÉNÉRALITÉS SUR LA MÉTHODE DE MONTE CARLO</a></h2>
<p>La méthode de Monte Carlo est une technique utilisée pour estimer des valeurs en utilisant des nombres aléatoires. Dans ce cas, nous utilisons la méthode de Monte Carlo pour estimer la valeur de pi.</p>
<p>Pour ce faire, nous générons un grand nombre de points aléatoires dans un carré et nous comptons combien de ces points se trouvent à l'intérieur d'un cercle inscrit dans ce carré.</p>
<p>En utilisant la formule de l'aire d'un cercle, nous pouvons estimer la valeur de pi en calculant le rapport entre le nombre de points à l'intérieur du cercle et le nombre total de points.</p>
<p>Dans notre cas, nous allons générer 10 000 points aléatoires. Nous allons ensuite vérifier si chaque point se trouve à l'intérieur ou à l'extérieur du cercle en utilisant la formule de la distance entre deux points.</p>
<p>Nous allons stocker les coordonnées des points à l'intérieur et à l'extérieur du cercle dans des listes séparées.</p>
<p>Enfin, nous allons calculer le rapport entre le nombre de points à l'intérieur du cercle et le nombre total de points pour estimer la valeur de pi.</p>
<h2 id="boucle-pour-générer-des-points-aléatoires"><a class="header" href="#boucle-pour-générer-des-points-aléatoires">Boucle pour générer des points aléatoires</a></h2>
<p>Pour générer des points aléatoires, nous utilisons une boucle. Une boucle est une instruction qui répète une action plusieurs fois. Dans notre cas, nous voulons générer un certain nombre de points aléatoires.</p>
<p>Voici comment nous faisons cela en utilisant une boucle :</p>
<pre><code class="language-python">for i in range(num_points):
    # Code pour générer un point aléatoire
</code></pre>
<p>Dans cette boucle, <code>num_points</code> est le nombre de points que nous voulons générer. La variable <code>i</code> est utilisée pour compter le nombre de fois que la boucle a été exécutée.</p>
<p>À l'intérieur de la boucle, nous écrivons le code pour générer un point aléatoire. Cela peut être n'importe quel code qui génère un point aléatoire, en fonction de ce que vous voulez faire avec les points.</p>
<p>Par exemple, si nous voulons générer des points aléatoires dans un carré de 10x10, nous pouvons utiliser le code suivant :</p>
<pre><code class="language-python">import random

for i in range(num_points):
    x = random.uniform(0, 10)
    y = random.uniform(0, 10)
    print(f&quot;Point {i+1}: ({x}, {y})&quot;)
</code></pre>
<p>Dans cet exemple, nous utilisons la fonction <code>random.uniform(a, b)</code> pour générer des nombres aléatoires entre <code>a</code> et <code>b</code>. Nous utilisons ensuite ces nombres pour définir les coordonnées <code>x</code> et <code>y</code> de chaque point. Enfin, nous imprimons les coordonnées de chaque point à l'écran.</p>
<p>C'est ainsi que nous utilisons une boucle pour générer des points aléatoires.</p>
<h2 id="générer-des-coordonnées-x-et-y-aléatoires"><a class="header" href="#générer-des-coordonnées-x-et-y-aléatoires">Générer des coordonnées x et y aléatoires</a></h2>
<p>Pour générer des coordonnées x et y aléatoires, nous utilisons une fonction qui nous donne un nombre aléatoire entre -1 et 1 pour chaque coordonnée. </p>
<h2 id="calculer-la-distance-par-rapport-à-lorigine-00"><a class="header" href="#calculer-la-distance-par-rapport-à-lorigine-00">Calculer la distance par rapport à l'origine (0,0)</a></h2>
<p>La distance par rapport à l'origine (0,0) est calculée en utilisant la formule mathématique de la distance entre deux points dans un plan. Nous élevons au carré les coordonnées x et y, puis nous les additionnons et prenons la racine carrée du résultat. Cela nous donne la distance du point par rapport à l'origine.</p>
<h2 id="vérifier-si-le-point-est-à-lintérieur-ou-à-lextérieur-du-cercle"><a class="header" href="#vérifier-si-le-point-est-à-lintérieur-ou-à-lextérieur-du-cercle">Vérifier si le point est à l'intérieur ou à l'extérieur du cercle</a></h2>
<p>Si la distance calculée est inférieure ou égale à 1, cela signifie que le point est à l'intérieur du cercle. Si la distance est supérieure à 1, cela signifie que le point est à l'extérieur du cercle.</p>
<h2 id="calculer-pi-en-utilisant-le-nombre-de-points-à-lintérieur-et-à-lextérieur-du-cercle"><a class="header" href="#calculer-pi-en-utilisant-le-nombre-de-points-à-lintérieur-et-à-lextérieur-du-cercle">Calculer Pi en utilisant le nombre de points à l'intérieur et à l'extérieur du cercle</a></h2>
<p>Pour calculer Pi, nous utilisons le rapport entre le nombre de points à l'intérieur du cercle et le nombre total de points générés. Nous multiplions ce rapport par 4 pour obtenir une estimation de Pi.</p>
<h1 id="simplification-du-texte"><a class="header" href="#simplification-du-texte">Simplification du texte</a></h1>
<h2 id="affichage-du-résultat-de-lestimation-de-pi"><a class="header" href="#affichage-du-résultat-de-lestimation-de-pi">Affichage du résultat de l'estimation de Pi</a></h2>
<p>Pour afficher le résultat de l'estimation de Pi, nous utilisons la fonction <code>print()</code> en Python. Dans cet exemple, nous affichons que Pi est estimé à 4.</p>
<h1 id="créer-un-graphique-pour-visualiser-les-points-dans-et-hors-du-cercle"><a class="header" href="#créer-un-graphique-pour-visualiser-les-points-dans-et-hors-du-cercle">Créer un graphique pour visualiser les points dans et hors du cercle</a></h1>
<p>Pour créer un graphique qui montre les points à l'intérieur et à l'extérieur d'un cercle, nous allons utiliser la méthode de Monte Carlo. Cette méthode est utilisée pour estimer des valeurs en utilisant des nombres aléatoires.</p>
<h2 id="chapitre-2-gÉnÉralitÉs-sur-la-mÉthode-de-monte-carlo-1"><a class="header" href="#chapitre-2-gÉnÉralitÉs-sur-la-mÉthode-de-monte-carlo-1">CHAPITRE 2. GÉNÉRALITÉS SUR LA MÉTHODE DE MONTE CARLO</a></h2>
<p>Pour commencer, nous allons tracer les points à l'intérieur et à l'extérieur du cercle sur notre graphique. Les points à l'intérieur du cercle seront représentés en bleu et les points à l'extérieur en rouge.</p>
<p>Voici le code pour créer le graphique :</p>
<pre><code class="language-python">fig, ax = plt.subplots()
ax.set_aspect('equal', 'box')
ax.scatter(x_inside, y_inside, color='blue', marker='.')
ax.scatter(x_outside, y_outside, color='red', marker='.')
</code></pre>
<p>Dans ce code, &quot;x_inside&quot; et &quot;y_inside&quot; représentent les coordonnées des points à l'intérieur du cercle, tandis que &quot;x_outside&quot; et &quot;y_outside&quot; représentent les coordonnées des points à l'extérieur du cercle.</p>
<p>En utilisant ce graphique, nous pourrons visualiser les points dans et hors du cercle, ce qui nous aidera à comprendre la méthode de Monte Carlo plus facilement.
Ajouter un cercle à l'intérieur d'un carré pour représenter un cercle de taille 1.</p>
<h1 id="simulation-de-transport-des-particules-par-monte-carlo"><a class="header" href="#simulation-de-transport-des-particules-par-monte-carlo">Simulation de transport des particules par Monte Carlo</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>La simulation du transport des particules dans la matière est réalisée en utilisant la méthode Monte Carlo. Cette méthode permet de suivre l'histoire des particules primaires et secondaires créées lors des interactions avec la matière.</p>
<h2 id="simulation-de-transport-dune-particule-dans-la-matière"><a class="header" href="#simulation-de-transport-dune-particule-dans-la-matière">Simulation de transport d'une particule dans la matière</a></h2>
<p>La simulation du transport d'une particule dans la matière par Monte Carlo se déroule en plusieurs étapes :</p>
<h3 id="définition-de-la-géométrie"><a class="header" href="#définition-de-la-géométrie">Définition de la géométrie</a></h3>
<p>Il s'agit de définir les dimensions et la forme des milieux d'interaction où se déroule la simulation. On utilise des paramètres tels que les caractéristiques chimiques du milieu et les dimensions du milieu pour définir la géométrie de simulation.</p>
<h3 id="génération-des-particules"><a class="header" href="#génération-des-particules">Génération des particules</a></h3>
<p>On définit les informations associées à la particule, telles que la source de génération, la position initiale, l'énergie et la direction initiale.</p>
<h3 id="tirage-aléatoire-de-la-position-avant-la-prochaine-interaction"><a class="header" href="#tirage-aléatoire-de-la-position-avant-la-prochaine-interaction">Tirage aléatoire de la position avant la prochaine interaction</a></h3>
<p>On utilise la loi de Beer-Lambert pour déterminer la distance parcourue par la particule avant la prochaine interaction. Cette distance est tirée aléatoirement en utilisant un nombre aléatoire entre 0 et 1.</p>
<h3 id="vérification-de-la-position-prochaine"><a class="header" href="#vérification-de-la-position-prochaine">Vérification de la position prochaine</a></h3>
<p>On vérifie si la position prochaine de la particule est à l'intérieur de la géométrie définie. Si c'est le cas, la particule est avancée à cette position et son énergie est modifiée en fonction de l'interaction.</p>
<p>Le suivi de la particule est arrêté lorsque sa position prochaine est en dehors de la géométrie définie.</p>
<h2 id="transport-de-photons"><a class="header" href="#transport-de-photons">Transport de photons</a></h2>
<p>Pour les photons, les interactions principales sont l'effet photoélectrique, la diffusion Rayleigh, la diffusion Compton et la création de paires. Le type d'interaction est déterminé en utilisant les sections efficaces tabulées qui dépendent du matériau. Un nombre aléatoire est tiré pour sélectionner l'interaction correspondante.</p>
<p>Ces étapes permettent de simuler le transport des particules dans la matière en utilisant la méthode Monte Carlo.</p>
<h1 id="simplification-du-texte-1"><a class="header" href="#simplification-du-texte-1">Simplification du texte</a></h1>
<h2 id="chapitre-4-simulation-de-transport-des-particules-par-monte-carlo"><a class="header" href="#chapitre-4-simulation-de-transport-des-particules-par-monte-carlo">Chapitre 4: Simulation de transport des particules par Monte Carlo</a></h2>
<h3 id="44-transport-délectrons-et-de-positrons"><a class="header" href="#44-transport-délectrons-et-de-positrons">4.4 Transport d'électrons et de positrons</a></h3>
<p>Les électrons et les positrons sont des particules qui se déplacent de la même manière dans la matière. Ils subissent de nombreuses interactions avec une faible perte d'énergie le long de leur trajet. Pour suivre leur trajectoire, on utilise une technique appelée &quot;histoire condensée&quot;.</p>
<h4 id="441-la-technique-dhistoire-condensée"><a class="header" href="#441-la-technique-dhistoire-condensée">4.4.1 La technique d'histoire condensée</a></h4>
<p>Cette technique consiste à regrouper les interactions élémentaires des électrons en étapes et à échantillonner les effets globaux (énergie, direction, déplacement latéral) à partir de distributions appropriées.</p>
<h4 id="442-algorithme-de-transport-des-électrons"><a class="header" href="#442-algorithme-de-transport-des-électrons">4.4.2 Algorithme de transport des électrons</a></h4>
<p>Pour transporter les électrons, on peut les déplacer le long d'une ligne en ignorant les déviations dues aux diffusions multiples. Cependant, la taille des pas doit être suffisamment petite pour accepter cette approximation.</p>
<h3 id="45-transport-des-protons-et-des-ions-de-carbone"><a class="header" href="#45-transport-des-protons-et-des-ions-de-carbone">4.5 Transport des protons et des ions de carbone</a></h3>
<p>Le transport des protons et des ions de carbone est modélisé en divisant leur trajet en petites étapes. Il est régi par trois processus principaux : le pouvoir d'arrêt, la diffusion coulombienne et les interactions nucléaires.</p>
<h4 id="451-pouvoir-darrêt"><a class="header" href="#451-pouvoir-darrêt">4.5.1 Pouvoir d'arrêt</a></h4>
<p>Les ions perdent leur énergie en interagissant avec les électrons atomiques. La perte d'énergie pour chaque étape est calculée à partir des valeurs de pouvoir d'arrêt.</p>
<h4 id="452-diffusion"><a class="header" href="#452-diffusion">4.5.2 Diffusion</a></h4>
<p>Les protons se dispersent lorsqu'ils ralentissent en interagissant avec les noyaux. On peut utiliser des fonctions de densité de probabilité pour calculer l'angle de diffusion à la fin de chaque étape.</p>
<h4 id="453-interactions-nucléaires"><a class="header" href="#453-interactions-nucléaires">4.5.3 Interactions nucléaires</a></h4>
<p>Les particules d'un faisceau ionique interagissent avec les noyaux atomiques, ce qui peut entraîner la production de neutrons, d'autres particules et d'isotopes à vie courte.</p>
<h3 id="46-conclusion"><a class="header" href="#46-conclusion">4.6 Conclusion</a></h3>
<p>Dans ce chapitre, nous avons examiné les étapes du transport des particules dans un milieu biologique, tel que le transport des photons, des électrons, des protons et des ions de carbone. Nous utiliserons le code Monte Carlo PHITS pour simuler ces processus.</p>
<h2 id="chapitre-5-simulation-par-le-code-phits"><a class="header" href="#chapitre-5-simulation-par-le-code-phits">Chapitre 5: Simulation par le code PHITS</a></h2>
<h3 id="51-introduction"><a class="header" href="#51-introduction">5.1 Introduction</a></h3>
<p>PHITS (Particle and Heavy Ion Transport code System) est un code de simulation de transport de particules largement utilisé dans le monde entier. Il peut simuler le transport de différentes particules sur une large gamme d'énergie en utilisant divers modèles de réactions nucléaires et bibliothèques de données.</p>
<h3 id="52-description-du-fichier-dentrée"><a class="header" href="#52-description-du-fichier-dentrée">5.2 Description du fichier d'entrée</a></h3>
<p>Le fichier d'entrée de PHITS est un texte qui permet de définir les paramètres et les variables nécessaires à la simulation. Il comprend des sections pour définir les caractéristiques des particules à simuler, la géométrie de l'espace virtuel et les matériaux utilisés.</p>
<h3 id="53-les-modèles-physiques-dans-phits"><a class="header" href="#53-les-modèles-physiques-dans-phits">5.3 Les modèles physiques dans PHITS</a></h3>
<p>PHITS utilise différents modèles physiques pour simuler les réactions nucléaires et le transport des particules. Certains de ces modèles incluent JAM et INCL4.6 pour la cascade hadronique, JQMD pour les ions lourds, SMM pour la fragmentation statistique, GEM pour l'évaporation statistique et JENDL-4.0 pour les données nucléaires.</p>
<h3 id="54-conclusion"><a class="header" href="#54-conclusion">5.4 Conclusion</a></h3>
<p>Dans ce chapitre, nous avons présenté le fonctionnement du code PHITS et les modèles physiques utilisés pour la simulation de transport des particules.</p>
<h1 id="ajouter-une-légende-pour-les-points"><a class="header" href="#ajouter-une-légende-pour-les-points">Ajouter une légende pour les points</a></h1>
<p>Les points sur la figure 5.3 représentent différents modèles physiques utilisés dans ce code. </p>
<h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<p>L'utilisation d'un faisceau de particules pour traiter les tumeurs cancéreuses nécessite une étude préliminaire détaillée. Cette étude vise à détruire uniquement les tumeurs tout en préservant les organes sains. Pour cela, nous utilisons une simulation basée sur le code PHITS, qui donne des résultats proches de la réalité.</p>
<p>Dans ce travail, nous utilisons le code PHITS pour simuler le transport des particules utilisées en hadronthérapie (protons, 12C, neutrons...). Nous déterminons les caractéristiques balistiques des protons et des ions de carbone 12, ainsi que le suivi des particules secondaires qui contribuent à la déposition de dose.</p>
<h1 id="matériel-et-méthode"><a class="header" href="#matériel-et-méthode">Matériel et Méthode</a></h1>
<p>La première étape de la simulation consiste à créer un objet simple en forme de parallélépipède de dimensions 20 cm x 20 cm x 40 cm.</p>
<p>Ensuite, nous créons une source de faisceau cylindrique de protons avec un diamètre de 8 cm et une énergie de 140 MeV. Le faisceau est dirigé le long de l'axe z.</p>
<p>Nous utilisons de l'eau comme matériau dans cette simulation, avec une masse volumique de 1 g/cm³. Nous incluons également du polyéthylène (C2H) dans la simulation pour valider le code utilisé.</p>
<p>La source est positionnée à une distance de 40 cm de l'objet.</p>
<h1 id="validation-du-code-phits"><a class="header" href="#validation-du-code-phits">Validation du code PHITS</a></h1>
<p>Dans cette partie préliminaire, nous simulons le transport des ions carbone (12C) d'énergie 200,2 MeV/u dans le polyéthylène (C2H) à l'aide du code PHITS. Nous comparons les résultats de la simulation avec les mesures expérimentales réalisées par la NASA au Laboratoire des Radiations du Département de l'Énergie. Cela nous permet d'évaluer la fiabilité du code.</p>
<p>Les résultats de la simulation et les mesures sont présentés dans la figure 6.2. Les résultats de la simulation sont en accord avec l'expérience, avec une petite différence au niveau du pic de Bragg. Cette différence s'explique par plusieurs paramètres, notamment le pas de simulation et la méthode utilisée pour calculer la dose.</p>
<p>En conclusion, cette petite différence est acceptable en raison des incertitudes des mesures expérimentales et des modèles physiques utilisés dans le code PHITS.</p>
<h1 id="simulation-du-transport-des-protons"><a class="header" href="#simulation-du-transport-des-protons">Simulation du transport des protons</a></h1>
<p>Dans cette partie, nous simulons le transport d'énergie par un faisceau contenant 10^7 protons monoénergétiques dans l'eau. En utilisant l'observable tally, nous déterminons la dose absorbée le long de l'axe du faisceau et latéralement par la cible.</p>
<h2 id="caractéristique-longitudinale-des-protons"><a class="header" href="#caractéristique-longitudinale-des-protons">Caractéristique longitudinale des protons</a></h2>
<p>La figure 6.3 montre la courbe de la dose absorbée par l'objet en fonction de la profondeur obtenue par le code PHITS. Les protons déposent le maximum d'énergie à une profondeur spécifique (z = 13,75 cm) où se trouve le pic de Bragg. Au-delà de ce pic, la dose absorbée est faible, ce qui indique une dispersion longitudinale du faisceau faible. Cela rend le traitement par des protons avantageux par rapport aux rayons X et aux électrons.</p>
<h2 id="contribution-en-profondeur-des-particules-secondaires"><a class="header" href="#contribution-en-profondeur-des-particules-secondaires">Contribution en profondeur des particules secondaires</a></h2>
<p>Les collisions des protons avec les électrons et les noyaux du milieu cible produisent des particules secondaires, telles que des neutrons, des photons, des deutérons, du tritium et des électrons. Ces particules contribuent à une faible dose, principalement avant et au pic de Bragg. Après le pic de Bragg, la dose est déposée principalement par les particules neutrons et photons dont la trajectoire dépasse 20 cm dans l'eau. Les isotopes lourds 7H et 3H sont arrêtés par le milieu avant le pic de Bragg.</p>
<h1 id="afficher-le-graphique"><a class="header" href="#afficher-le-graphique">Afficher le graphique</a></h1>
<p>La matière est importante, ce qui s'accompagne d'une diminution d'énergie au fur et à mesure jusqu'à une énergie faible qui sera déposée intégralement sous forme de pic.</p>
<div class="table-wrapper"><table><thead><tr><th>Énergies (MeV)</th><th>Position du pic de Bragg</th><th>Largeur à mi-hauteur (cm)</th></tr></thead><tbody>
<tr><td>50</td><td>2,1</td><td>0,2</td></tr>
<tr><td>95</td><td>6,9</td><td>0,3</td></tr>
<tr><td>140</td><td>13,8</td><td>0,4</td></tr>
<tr><td>200</td><td>25,8</td><td>0,6</td></tr>
</tbody></table>
</div>
<p><strong>Tableau 6.1</strong> - Largeur à mi-hauteur pour différentes énergies de protons.</p>
<p>D'après le tableau 6.1, nous constatons que lorsque la profondeur dans l'eau augmente, la largeur à mi-hauteur augmente. Cela traduit une dispersion du faisceau de protons et une perte de précision du dépôt de dose avec la profondeur.</p>
<h2 id="65-simulation-de-transport-dions-carbone-12"><a class="header" href="#65-simulation-de-transport-dions-carbone-12">6.5 Simulation de transport d'ions Carbone 12</a></h2>
<p>Nous reprenons le matériel et la géométrie utilisés précédemment en remplaçant la source de protons par une source d'ions de carbone 12 d'énergie E=264 MeV. La dose absorbée en profondeur par le fantôme est calculée dans la section tally, précisément par [T-Deposit].</p>
<p><strong>Dose en profondeur</strong></p>
<p>Le code PHITS donne la courbe de la dose en profondeur sur la figure 6.9 :</p>
<p><img src="image.png" alt="Figure 6.9" /></p>
<p>La courbe (figure 6.9) montre que les ions de carbone 12 primaires sont principalement responsables de la dose déposée, environ 93%, dans le fantôme avant et au pic de Bragg. Cependant, les particules secondaires ne contribuent qu'à 7% de la dose totale déposée.</p>
<p>Au pic de Bragg pour z = 13,8 cm, tous les ions de carbone 12 du faisceau primaire sont arrêtés par le milieu, marquant la fin de leur parcours. Après le pic de Bragg, il y a une apparition d'une queue de dose appelée queue de fragmentation, qui est due aux particules secondaires (protons, neutrons, 10B, 4He, 12C...) se produisant par la fragmentation et qui sont responsables de la dose déposée.</p>
<ol>
<li>Le taux de dose : égal à la dose déposée à la position z donnée sur celle déposée au pic de Bragg.</li>
</ol>
<h2 id="Étude-des-fragments"><a class="header" href="#Étude-des-fragments">Étude des fragments</a></h2>
<p>Le suivi des fragments par le code PHITS permet d'obtenir les résultats de la figure 6.10. Les particules secondaires contribuent principalement à la dose totale, mais avec une faible dose. Les particules H*, fragments 10B et 4He contribuent à la dose déposée, mais le taux de contribution des neutrons ne dépasse pas 0,02%. Avant le pic de Bragg, leur contribution est faible par rapport aux ions de carbone incidents, et après le pic, la courbe de dose totale est presque confondue avec celle de toutes les particules secondaires.</p>
<p>La distribution de dose des fragments 12C et 10B montre une chute sous forme de pic, indiquant la fin de leur parcours. Les fragments légers sont émis vers l'avant et leur parcours dans l'eau est long, environ 40 cm, tandis que le parcours des fragments lourds est court.</p>
<p>Le tableau 6.2 donne le parcours et le taux de contribution en dose des différentes particules secondaires.</p>
<p><strong>Tableau 6.2</strong> - Taux de contribution en dose (%) pour différentes particules secondaires dans l'eau.</p>
<h2 id="66-comparaison-entre-lion-carbone-et-un-ion-lourd-et-léger"><a class="header" href="#66-comparaison-entre-lion-carbone-et-un-ion-lourd-et-léger">6.6 Comparaison entre l'ion carbone et un ion lourd et léger</a></h2>
<p>Nous comparons les caractéristiques d'un ion carbone d'énergie E=270 MeV/u d'une part avec un ion léger H* et d'autre part avec un ion lourd 7Ne.</p>
<h3 id="661-ion-carbone-et-proton"><a class="header" href="#661-ion-carbone-et-proton">6.6.1 Ion carbone et proton</a></h3>
<p>La dispersion longitudinale</p>
<p>Le code PHITS permet d'obtenir la dose en profondeur, figure 6.11.</p>
<p><img src="image.png" alt="Figure 6.11" /></p>
<p>Le tableau 6.3 résume les résultats de la figure 6.11, en donnant la largeur à mi-hauteur et le taux de dispersion en profondeur des deux ions.</p>
<p><strong>Tableau 6.3</strong> - Données de largeur à mi-hauteur et de taux de dispersion en profondeur pour différents ions.</p>
<p>À partir du tableau, on peut conclure que :</p>
<ul>
<li>Le faisceau de protons a une faible précision de dépôt de dose par rapport aux ions carbone.</li>
<li>Les ions carbone ont une faible dispersion en profondeur par rapport aux protons.</li>
</ul>
<h3 id="662-ion-carbone-et-ion-de-néon"><a class="header" href="#662-ion-carbone-et-ion-de-néon">6.6.2 Ion carbone et ion de néon</a></h3>
<p>La dispersion longitudinale</p>
<p>La simulation par le code PHITS d'un faisceau d'ions carbone et d'un faisceau d'ions néon permet d'obtenir les courbes de la figure 6.12.</p>
<p><img src="image.png" alt="Figure 6.12" /></p>
<p>Nous constatons que la dose déposée avant le pic de Bragg par les ions carbone est quasi-ment constante et faible par rapport aux ions de néon. Après le pic, la queue de fragmentation des ions néon est plus importante que celle des ions carbone. Cependant, la dispersion en profondeur est la même pour les deux ions.</p>
<p>Dans le tableau 6.4, nous calculons le taux de dose par rapport à celle déposée au pic de Bragg à l'entrée z=0 du fantôme et juste après le pic z=27,6 cm.</p>
<p><strong>Tableau 6.4</strong> - Taux de dose par rapport au pic de Bragg pour les ions de carbone et les ions de néon.</p>
<h2 id="67-conclusion"><a class="header" href="#67-conclusion">6.7 Conclusion</a></h2>
<p>Un dépôt d'énergie modéré et quasi constant en entrée et maximal en fin de parcours par les ions de carbone 12 et de protons, une faible dispersion en profondeur et latéralement permettent d'irradier précisément le volume ciblé pour détruire les tumeurs tout en protégeant les organes sains situés en entrée. Cette caractéristique met en évidence l'intérêt balistique des ions pour un traitement par rapport aux électrons et aux rayons X.</p>
<p>Le traitement avec les ions carbone est plus efficace que celui des protons. En effet, les ions de carbone 12 ont une efficacité biologique relative entre 2 et 4, tandis que celle des protons est quasiment constante avec une valeur EBR = 1,1.</p>
<h2 id="conclusion-générale"><a class="header" href="#conclusion-générale">Conclusion générale</a></h2>
<p>Dans ce travail, nous avons présenté un aperçu du principe d'interaction des particules avec la matière, nécessaire pour comprendre le transport et le transfert d'énergie d'une particule dans un milieu biologique. Nous avons également abordé la méthode de Monte Carlo, qui repose sur l'échantillonnage aléatoire et permet d'estimer la valeur de pi, ainsi que d'autres problèmes étudiés.</p>
<p>Nous avons étudié les résultats de transport de protons et d'ions carbone par le code PHITS. Nous avons validé notre code en comparant les mesures dans le polyéthylène données par la NASA avec les courbes de Bragg obtenues par simulation. Nous avons ensuite réalisé une simulation d'un faisceau de protons et d'ions carbone 12 dans l'eau, et les résultats obtenus sont conformes aux travaux publiés dans ce domaine.</p>
<p>Nous avons également étudié la fragmentation des ions carbone 12 et son impact sur la dose déposée. Nous avons comparé les caractéristiques des ions carbone avec celles des ions légers et des ions lourds, montrant ainsi l'efficacité des ions carbone dans le traitement des tumeurs.</p>
<p>Ce travail représente une initiation à la recherche en physique médicale, et son expansion sera une perspective pour les années à venir. Il permettra d'améliorer notre connaissance du comportement des ions dans un milieu biologique, d'étudier les fragments produits et leurs propriétés, et d'améliorer les moyens de radioprotection contre les particules secondaires, notamment les neutrons.</p>
<h1 id="afficher-le-graphique-1"><a class="header" href="#afficher-le-graphique-1">Afficher le graphique</a></h1>
<p>K. GUNZERT-MARX, D. SCHARDT et R. S. SIMON, &quot;Fast neutrons produced by nuclear fragmentation in treatment irradiations with 12C beam&quot;, Radiation protection dosimetry, vol. 110, n° 1-4, p. 595-600, 2004.</p>
<p>D. SCHARDT et al., &quot;Nuclear fragmentation of high-energy heavy-ion beams in water&quot;, Advances in Space Research, vol. 17, n° 2, p. 87-94, 1996.</p>
<p>67</p>
<p>REFERENCES</p>
<p>[50] N. Marsurugi, A. FukuMuRA, M. Komori, T. KANAI et T. KOHNO, &quot;Influence of fragment reaction of relativistic heavy charged particles on heavy-ion radiotherapy&quot;, Physics in Medicine &amp; Biology, vol. 48, n° 11, p. 1605, 2003.</p>
<p>[51] H. MACCABEE et M. RITTER, &quot;Fragmentation of high-energy oxygen-ion beams in water&quot;, Radiation Research, vol. 60, n° 3, p. 409-421, 1974.</p>
<p>[52] J. LLACER, C. TOBIAS, W. HOLLEY et T. KANAI, &quot;On-line characterization of heavy-ion beams with semiconductor detectors&quot;, Medical physics, vol. 11, n° 3, p. 266-278, 1984.</p>
<p>[53] E. HAETTNER, H. IWASE, M. KRAMER, G. KRAFT et D. SCHARDT, &quot;Experimental study of nuclear fragmentation of 200 and 400 MeV/u 12C ions in water for applications in particle therapy&quot;, Physics in medicine &amp; biology, vol. 58, n° 23, p. 8265, 2013.</p>
<p>68</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h1>
<p>La simulation consiste à imiter des situations réelles pour résoudre des problèmes complexes. Cela permet de comprendre comment les choses fonctionnent et comment différents éléments interagissent les uns avec les autres. Dans ce texte, nous allons parler de la simulation par la méthode de Monte Carlo, une technique informatique pour résoudre des problèmes difficiles. Elle est utilisée dans divers domaines, y compris la médecine.</p>
<h1 id="la-méthode-de-monte-carlo"><a class="header" href="#la-méthode-de-monte-carlo">La Méthode de Monte Carlo</a></h1>
<p>La méthode de Monte Carlo est une manière de résoudre des problèmes en utilisant des nombres aléatoires. Cela consiste à faire des &quot;essais&quot; aléatoires pour trouver une solution. Cette méthode est utile dans des domaines comme la physique, la chimie et la biologie. Elle est également utilisée en médecine, notamment en radiothérapie.</p>
<h1 id="simulation-en-médecine"><a class="header" href="#simulation-en-médecine">Simulation en Médecine</a></h1>
<p>En médecine, la simulation par Monte Carlo est utilisée dans des domaines tels que la radiothérapie. Cela aide à comprendre comment les rayonnements agissent sur les tumeurs et les tissus sains. Cette simulation est importante pour le traitement du cancer.</p>
<h1 id="la-radiothérapie"><a class="header" href="#la-radiothérapie">La Radiothérapie</a></h1>
<p>La radiothérapie est une méthode de traitement du cancer qui utilise des rayonnements pour détruire les cellules cancéreuses tout en préservant les tissus sains. Elle est souvent utilisée en combinaison avec d'autres traitements, comme la chirurgie ou la chimiothérapie.</p>
<h1 id="la-hadronthérapie"><a class="header" href="#la-hadronthérapie">La Hadronthérapie</a></h1>
<p>La hadronthérapie est une technique de traitement du cancer qui utilise des particules appelées hadrons, comme les protons et les ions carbone. Ces particules sont efficaces pour traiter des tumeurs résistantes. Elles sont utilisées pour cibler spécifiquement les cellules cancéreuses.</p>
<h1 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h1>
<p>La simulation par la méthode de Monte Carlo est une technique puissante pour résoudre des problèmes complexes. En médecine, elle est utilisée pour comprendre comment les rayonnements agissent sur les tumeurs. Cela aide les médecins à planifier des traitements efficaces pour les patients atteints de cancer.
Bien sûr, voici le texte simplifié avec le formatage Markdown :</p>
<h1 id="nombre-de-points-à-utiliser-pour-lestimation-1"><a class="header" href="#nombre-de-points-à-utiliser-pour-lestimation-1">Nombre de points à utiliser pour l'estimation</a></h1>
<p>Le nombre de points que nous allons utiliser pour estimer est de 10 000.</p>
<p>J'ai corrigé les erreurs d'orthographe, de ponctuation et de formatage tout en maintenant le contenu intact.
Bien sûr, voici une version simplifiée de votre texte en utilisant le format Markdown et en suivant les étapes que vous avez fournies :</p>
<h2 id="comptage-des-points-dans-le-cercle"><a class="header" href="#comptage-des-points-dans-le-cercle">Comptage des Points dans le Cercle</a></h2>
<p>Pour compter les points à l'intérieur d'un cercle, nous utilisons une variable appelée &quot;count_inside&quot;.</p>
<pre><code class="language-markdown">count_inside = 0
</code></pre>
<p>Cela signifie que nous avons une variable pour compter combien de points se trouvent à l'intérieur du cercle. Cette variable commence à zéro.</p>
<p>Assurez-vous que votre travail est simple à comprendre et évitez d'utiliser des mots ou des concepts difficiles. Utilisez des exemples clairs et des phrases courtes pour expliquer vos idées.</p>
<h1 id="simplification-en-markdown-"><a class="header" href="#simplification-en-markdown-">Simplification en Markdown :</a></h1>
<h2 id="simplification-dun-texte-pour-débutant"><a class="header" href="#simplification-dun-texte-pour-débutant">Simplification d'un texte pour débutant</a></h2>
<ol>
<li><strong>Explication claire des mots difficiles</strong>.</li>
<li>Utilisation de <strong>phrases courtes et simples</strong>.</li>
<li>Utilisation de mots <strong>connus par la plupart des gens</strong>.</li>
<li>Ajout d'<strong>exemples faciles à comprendre</strong>.</li>
<li><strong>Éviter les termes techniques</strong>.</li>
<li>Diviser les idées complexes en <strong>étapes plus petites</strong>.</li>
<li>Suivre l'<strong>ordre sujet-verbe-objet</strong> dans les phrases.</li>
<li><strong>Minimiser l'utilisation de mots modificateurs</strong>.</li>
<li>Utiliser des mots qui montrent les <strong>relations entre les idées</strong>.</li>
<li><strong>Relecture attentive pour la clarté</strong>.</li>
</ol>
<hr />
<h2 id="utilisation-de-listes-pour-stocker-les-coordonnées"><a class="header" href="#utilisation-de-listes-pour-stocker-les-coordonnées">Utilisation de listes pour stocker les coordonnées</a></h2>
<ul>
<li>x_inside : Liste pour les coordonnées x à l'intérieur du cercle.</li>
<li>y_inside : Liste pour les coordonnées y à l'intérieur du cercle.</li>
<li>x_outside : Liste pour les coordonnées x à l'extérieur du cercle.</li>
<li>y_outside : Liste pour les coordonnées y à l'extérieur du cercle.</li>
</ul>
<hr />
<h2 id="chapitre-2--gÉnÉralitÉs-sur-la-mÉthode-de-monte-carlo"><a class="header" href="#chapitre-2--gÉnÉralitÉs-sur-la-mÉthode-de-monte-carlo">CHAPITRE 2 : GÉNÉRALITÉS SUR LA MÉTHODE DE MONTE CARLO</a></h2>
<pre><code class="language-python">
</code></pre>
<p>Voici le texte simplifié avec le formatage Markdown :</p>
<pre><code class="language-markdown"># Boucle pour générer des points aléatoires

Pour créer des points aléatoires, nous utilisons une boucle, qui est essentiellement une série d'instructions répétées plusieurs fois. Voici comment cela fonctionne :

```python
for i in range(num_points):
</code></pre>
<p>Cette partie du code signifie que nous allons répéter ce qui suit plusieurs fois, où <code>num_points</code> est le nombre de points que nous voulons créer. En gros, imaginez que nous dessinons des points sur une feuille de papier, et nous voulons décider combien de points nous voulons dessiner, disons 10 points. Donc, cette boucle dit &quot;dessinez un point&quot; 10 fois.</p>
<pre><code>
J'ai simplifié le texte et ajouté des exemples pour rendre les idées plus claires. J'espère que cela vous aide !
# Générer des coordonnées aléatoires

Pour créer des coordonnées x et y aléatoires, nous utilisons la bibliothèque `random` en Python. Voici comment le faire :

```python
import random

# Générer les coordonnées x et y
x = random.uniform(-1, 1)
y = random.uniform(-1, 1)
</code></pre>
<p>Dans ce code, <code>random.uniform(a, b)</code> génère un nombre aléatoire entre <code>a</code> et <code>b</code>. Ainsi, <code>x</code> et <code>y</code> seront des nombres aléatoires compris entre -1 et 1.</p>
<p>Assurez-vous d'inclure l'importation de la bibliothèque <code>random</code> pour utiliser la fonction <code>uniform</code>.
Bien sûr ! Voici le texte simplifié en utilisant le formatage Markdown et en suivant les étapes indiquées :</p>
<pre><code class="language-markdown">## Calculer la distance depuis l'origine (0,0)

Pour trouver la distance d'un point depuis le point de départ (0,0), utilisez cette formule :
distance = racine carrée de (x au carré + y au carré)

- Si la distance est de 1 ou moins, le point est à l'intérieur du cercle.
- Si la distance est plus de 1, le point est à l'extérieur du cercle.

Exemple : Si x = 3 et y = 4, la distance est 5.
</code></pre>
<p>J'espère que cela rend les concepts plus accessibles ! Si vous avez d'autres questions, n'hésitez pas à demander.
Bien sûr, voici le texte simplifié en utilisant le formatage Markdown :</p>
<h1 id="calculer-pi-en-utilisant-le-nombre-de-points-à-lintérieur-et-à-lextérieur-du-cercle-1"><a class="header" href="#calculer-pi-en-utilisant-le-nombre-de-points-à-lintérieur-et-à-lextérieur-du-cercle-1">Calculer Pi en utilisant le nombre de points à l'intérieur et à l'extérieur du cercle</a></h1>
<p>Pour trouver Pi, suivez ces étapes simples :</p>
<ol>
<li>D'abord, dessinez un cercle.</li>
<li>Ensuite, lancez des points aléatoires à l'intérieur d'un carré qui encercle ce cercle.</li>
<li>Comptez combien de points sont à l'intérieur du cercle et combien sont à l'extérieur.</li>
<li>Utilisez cette formule : Pi = 4 * (nombre de points à l'intérieur) / (nombre total de points).</li>
</ol>
<p>C'est tout ! Vous pouvez ainsi estimer la valeur de Pi en utilisant cette méthode.
Bien sûr, voici le texte simplifié en utilisant le format Markdown :</p>
<h1 id="estimation-de-pi"><a class="header" href="#estimation-de-pi">Estimation de Pi</a></h1>
<p>Pour estimer Pi, vous pouvez utiliser cette formule simple :</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3.14</span></span></span></span></span></p>
<p>Cela signifie que Pi est environ égal à 3.14. Vous pouvez l'utiliser lorsque vous avez besoin d'une valeur proche de Pi, mais n'avez pas besoin d'une précision extrême.</p>
<p>Voici un exemple : Si vous avez un cercle avec un rayon de 1 mètre, la circonférence (la distance autour du cercle) serait d'environ 6.28 mètres, car 2 * 3.14 est environ égal à 6.28.</p>
<p>N'oubliez pas de vérifier vos calculs pour vous assurer qu'ils sont corrects !</p>
<h1 id="création-dun-graphique-pour-visualiser-les-points-à-lintérieur-et-à-lextérieur-du-cercle"><a class="header" href="#création-dun-graphique-pour-visualiser-les-points-à-lintérieur-et-à-lextérieur-du-cercle">Création d'un graphique pour visualiser les points à l'intérieur et à l'extérieur du cercle</a></h1>
<p>Pour commencer, créons un graphique pour représenter les points situés à l'intérieur et à l'extérieur d'un cercle. Utilisons le format Markdown pour rendre cela plus clair.</p>
<h2 id="Étape-1-préparation-du-graphique"><a class="header" href="#Étape-1-préparation-du-graphique">Étape 1: Préparation du graphique</a></h2>
<pre><code class="language-python">import matplotlib.pyplot as plt

# Création de l'axe du graphique
fig, ax = plt.subplots()
ax.set_aspect('equal', 'box')
</code></pre>
<h2 id="Étape-2-simplification-du-texte"><a class="header" href="#Étape-2-simplification-du-texte">Étape 2: Simplification du texte</a></h2>
<p>Assurons-nous que le texte est compréhensible en suivant ces étapes simples :</p>
<ul>
<li>Expliquons les mots difficiles de manière simple.</li>
<li>Utilisons des phrases courtes et des mots connus.</li>
<li>Intégrons des exemples faciles à comprendre.</li>
</ul>
<h2 id="Étape-3-clarification-des-idées-complexes"><a class="header" href="#Étape-3-clarification-des-idées-complexes">Étape 3: Clarification des idées complexes</a></h2>
<p>Divisons les idées complexes en parties plus petites pour les rendre plus accessibles.</p>
<h2 id="Étape-4-révision-du-texte"><a class="header" href="#Étape-4-révision-du-texte">Étape 4: Révision du texte</a></h2>
<p>Vérifions soigneusement le texte pour garantir qu'il est clair et facile à lire.
Bien sûr, voici le texte simplifié en utilisant le format Markdown :</p>
<h1 id="tracez-les-points-dans-et-hors-du-cercle"><a class="header" href="#tracez-les-points-dans-et-hors-du-cercle">Tracez les points dans et hors du cercle</a></h1>
<p>24</p>
<h2 id="chapitre-2--introduction-à-la-méthode-de-monte-carlo"><a class="header" href="#chapitre-2--introduction-à-la-méthode-de-monte-carlo">CHAPITRE 2 : Introduction à la méthode de Monte Carlo</a></h2>
<p>Pour représenter les points à l'intérieur et à l'extérieur du cercle en utilisant Python, vous pouvez utiliser le code suivant :</p>
<pre><code class="language-python">ax.scatter(x_inside, y_inside, color='blue', marker='.')
ax.scatter(x_outside, y_outside, color='red', marker='.')
</code></pre>
<p>Pour ajouter un cercle inscrit dans un carré pour représenter le cercle unité, vous pouvez utiliser ce code :</p>
<pre><code class="language-python">circle = plt.Circle((0, 0), 1, color='green', fill=False)
ax.add_artist(circle)
</code></pre>
<p>N'oubliez pas d'ajouter une légende pour les points comme ceci :</p>
<pre><code class="language-python">ax.legend(['Points dans le cercle', 'Points hors du cercle'])
</code></pre>
<p>J'ai simplifié le texte en respectant les directives que vous avez fournies. Si vous avez d'autres questions ou besoin de plus de détails, n'hésitez pas à demander !
Le processus de Markov signifie que le chemin global d'une particule peut être divisé en petits sous-chemins indépendants.</p>
<h2 id="chapitre-4--simulation-du-transport-des-particules-par-monte-carlo"><a class="header" href="#chapitre-4--simulation-du-transport-des-particules-par-monte-carlo">Chapitre 4 : Simulation du transport des particules par Monte Carlo</a></h2>
<p>La particule est avancée à la prochaine position d'interaction : (X_{i+1} = X_i + S \cdot \vec{Q}) (équation 20).<br />
Avec :</p>
<ul>
<li>(X_i): la position de la particule où l'interaction (i) a eu lieu.</li>
<li>(X_{i+1}): la position de la prochaine interaction (i + 1).</li>
<li>(S = \ln(\zeta)): la distance parcourue par la particule entre deux interactions successives.</li>
<li>(\vec{Q}): le vecteur directeur.<br />
L'énergie de la particule est modifiée lors de l'interaction.<br />
Le suivi de la particule s'arrête lorsque sa prochaine position (X_{i+1}) est en dehors de la géométrie définie par l'utilisateur.</li>
</ul>
<h2 id="43-transport-de-photons"><a class="header" href="#43-transport-de-photons">4.3 Transport de photons</a></h2>
<p>Le type d'interaction dépend du matériau et est basé sur les sections efficaces tabulées. Pour les énergies utilisées en radiothérapie, les principaux modes d'interaction des photons sont l'effet photoélectrique, la diffusion Rayleigh (cohérente), la diffusion Compton (incohérente) et la création de paires, avec les sections efficaces respectives notées : (\sigma_{\text{PE}}, \sigma_{\text{Ray}}, \sigma_{\text{Compton}}, \sigma_{\text{Pair}}).<br />
Un nombre (E) est tiré aléatoirement entre 0 et 1, et la particule suit l'un de ces scénarios en fonction de la valeur de (E) :</p>
<ul>
<li>Si (E) est inférieur à (i), l'effet photoélectrique est sélectionné.</li>
<li>Si (E) est compris entre (i) et (j), la diffusion Rayleigh est sélectionnée.</li>
<li>Si (E) est compris entre (j) et (k), la diffusion Compton est sélectionnée.</li>
<li>Si (E) est supérieur à (k), la création de paires électron-positron est sélectionnée.</li>
</ul>
<h2 id="44-transport-délectrons-et-de-positrons-1"><a class="header" href="#44-transport-délectrons-et-de-positrons-1">4.4 Transport d'électrons et de positrons</a></h2>
<p>Les électrons et les positrons sont transportés de manière similaire dans la matière, avec des sections efficaces identiques. Cependant, lors du suivi des positrons, deux photons secondaires de 0,511 MeV sont émis dos à dos (180°).<br />
Les électrons subissent de nombreuses interactions avec une faible perte d'énergie le long de leur parcours, ce qui complique leur suivi. La technique de l'histoire condensée est utilisée pour résoudre ce problème.</p>
<h3 id="441-technique-de-lhistoire-condensée"><a class="header" href="#441-technique-de-lhistoire-condensée">4.4.1 Technique de l'histoire condensée</a></h3>
<p>Cette technique, basée sur le regroupement des changements élémentaires d'énergie et de direction des électrons, permet d'obtenir des effets globaux (énergie, direction, déplacement latéral) à partir de distributions appropriées.</p>
<h3 id="442-algorithme-de-transport-des-électrons-1"><a class="header" href="#442-algorithme-de-transport-des-électrons-1">4.4.2 Algorithme de transport des électrons</a></h3>
<p>Pour transporter les électrons pendant un pas de l'histoire condensée, on néglige la déviation due aux diffusions multiples le long de ce pas. Les électrons sont transportés le long d'une ligne. La taille du pas doit être suffisamment petite pour que cette approximation soit valable, mais trop petite taille de pas entraîne des temps de simulation excessifs.</p>
<h2 id="45-transport-des-protons-et-des-ions-de-carbone-1"><a class="header" href="#45-transport-des-protons-et-des-ions-de-carbone-1">4.5 Transport des protons et des ions de carbone</a></h2>
<p>Le transport des protons est modélisé en divisant leur trajet en petites étapes. Trois processus principaux les régissent : le pouvoir d'arrêt, la diffusion coulombienne et les interactions nucléaires.</p>
<h3 id="451-pouvoir-darrêt-1"><a class="header" href="#451-pouvoir-darrêt-1">4.5.1 Pouvoir d'arrêt</a></h3>
<p>Les ions perdent de l'énergie en interagissant avec les électrons atomiques. En utilisant l'équation de Bethe Bloch, la perte d'énergie pour chaque étape est calculée en fonction de la densité électronique du matériau.<br />
[ \frac{{dE}}{{dx}} = 4\pi N_{\text{A}} \frac{{z^2e^4}}{{me^2v^2}} \frac{{1}}{{\beta^2}} \left[\frac{{1}}{{2}} \ln\left(\frac{{2me^2v^2}}{{I^2}}\right) - \beta^2 - \frac{{\delta}}{{2}}\right] ]<br />
Avec :</p>
<ul>
<li>( p = \beta \gamma )</li>
<li>( v ) : vitesse de la particule</li>
<li>( c ) : vitesse de la lumière</li>
<li>( E ) : Énergie de la particule</li>
<li>( dx ) : longueur du chemin</li>
<li>( z ) : charge de la particule</li>
<li>( e ) : charge élémentaire</li>
<li>( m_e ) : masse au repos de l'électron</li>
<li>( n ) : densité électronique du matériau</li>
<li>( I ) : potentiel d'excitation moyen du matériau<br />
<img src="image_1.png" alt="Schéma de l'échantillonnage du trajet d'un ion" /></li>
</ul>
<h3 id="452-diffusion-1"><a class="header" href="#452-diffusion-1">4.5.2 Diffusion</a></h3>
<p>La dispersion des protons accompagne leur ralentissement dû aux interactions avec les noyaux. L'angle de diffusion à la fin de chaque étape est échantillonné en utilisant la technique de l'échantillonnage.<br />
<img src="image_2.png" alt="Schéma de diffusion d'un ion" />
Voici le texte simplifié en utilisant le format Markdown :</p>
<h1 id="afficher-le-graphique-dune-particule-dans-un-milieu-biologique"><a class="header" href="#afficher-le-graphique-dune-particule-dans-un-milieu-biologique">Afficher le graphique d'une particule dans un milieu biologique</a></h1>
<p>La méthode de Monte Carlo utilise l'échantillonnage aléatoire pour estimer des valeurs, comme π. Cette méthode nécessite de nombreuses itérations pour être précise. Elle est utilisée pour étudier le transport des particules et leurs interactions avec la matière.</p>
<p>Nous avons utilisé cette méthode pour simuler le transport de protons et d'ions carbone avec le code PHITS. Nous avons validé notre code en le comparant aux mesures de la NASA dans le polyéthylène, montrant une bonne concordance. Ensuite, nous avons simulé un faisceau de protons et d'ions carbone monoénergétiques dans l'eau, obtenant des résultats confirmés par d'autres travaux.</p>
<p>Le dépôt d'énergie dans l'eau par ces particules a une caractéristique commune : un pic de Bragg. Cependant, les particules secondaires diffèrent entre protons et ions carbone, avec ces derniers produisant des fragments secondaires le long de leur trajet.</p>
<p>Les ions carbone se révèlent plus efficaces que les protons, tout comme d'autres ions lourds tels que le néon et l'oxygène 18.</p>
<h2 id="conclusion-générale-1"><a class="header" href="#conclusion-générale-1">Conclusion générale</a></h2>
<p>La recherche sur l'utilisation des ions en thérapie tumorale, en particulier le carbone 12, se poursuit. Des améliorations des modèles nucléaires sont nécessaires.</p>
<p>Au cours de notre travail, nous avons rencontré des problèmes techniques liés au temps de simulation et au choix des codes. La simulation de nombreuses particules par Monte Carlo est chronophage, et la prise en main de certains codes peut être complexe.</p>
<p>Ce travail représente une initiation pour nous, et il ouvre la voie à de futures recherches visant à mieux comprendre le comportement des ions dans un milieu biologique, à étudier les fragments produits et à améliorer la radioprotection contre les particules secondaires, notamment les neutrons.
Bien sûr, voici le texte simplifié en utilisant le format Markdown :</p>
<h1 id="afficher-le-graphique-2"><a class="header" href="#afficher-le-graphique-2">Afficher le graphique</a></h1>
<p>Références :</p>
<ol>
<li>Influence de la réaction de fragmentation des particules chargées lourdes relativistes sur la radiothérapie par ions lourds (A. Fukumura, M. Komori, T. Kanai et T. Kohno, 2003).</li>
<li>Fragmentation des faisceaux d'ions oxygène à haute énergie dans l'eau (H. Maccabee et M. Ritter, 1974).</li>
<li>Caractérisation en ligne des faisceaux d'ions lourds avec des détecteurs semi-conducteurs (J. Llacer, C. Tobias, W. Holley et T. Kanai, 1984).</li>
<li>Étude expérimentale de la fragmentation nucléaire des ions ^12C de 200 et 400 MeV/u dans l'eau pour des applications en thérapie par particules (E. Haettner, H. Iwase, M. Kramer, G. Kraft et D. Schardt, 2013).</li>
<li>Neutrons rapides produits par fragmentation nucléaire dans les irradiations de traitement avec des faisceaux de ^12C (K. Gunzert-Marx, D. Schardt et R. S. Simon, 2004).</li>
<li>Fragmentation nucléaire de faisceaux d'ions lourds à haute énergie dans l'eau (D. Schardt et al., 1996).</li>
<li>Influence de la réaction de fragmentation des particules chargées lourdes relativistes sur la radiothérapie par ions lourds (N. Matsuruji, A. Fukumura, M. Komori, T. Kanai et T. Kohno, 2003).</li>
</ol>
<p>J'ai réorganisé les références avec des titres numérotés pour plus de clarté.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="1"><a class="header" href="#1">1</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="1-1"><a class="header" href="#1-1">1</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="1-2"><a class="header" href="#1-2">1</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="1-3"><a class="header" href="#1-3">1</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="8"><a class="header" href="#8">8</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id=""><a class="header" href="#"></a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<p>11.4.2. Erreur quadratique moyenne EQM.<br />
La fonction de coût est une fonction mathématique mesurée entre zéro et la valeur maximale possible. Plus la valeur de la fonction de coût est proche de zéro, plus les résultats générés sont proches des résultats cibles. Par exemple, nous utilisons la fonction de coût appelée erreur quadratique moyenne (EQM), qui calcule la moyenne de toutes les mesures d’erreur quadratique entre chaque résultat généré et chaque résultat cible.</p>
<p>E=\frac{1}{n} \sum_{i=1}^{n}(y^{i}-y_0^{i})^{2} (4) </p>
<p>Où n est le nombre de paires d’entrées et de résultats cibles, y^{i}) (ou (y^{0i})) est la mesure du résultat généré et (y_0^{i}) (ou (y^{0F}) est la mesure du résultat cible.</p>
<p>Ainsi, si nous utilisons EQM pour mesurer l’écart entre une fonction linéaire et un tableau de conversion des températures Celsius en Fahrenheit, la valeur de la EQM sera:</p>
<p>E = 1 / D – H<br />
= ((w * e + 6) – 90)^2
= 4480.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="./theme/tabbed-code-blocks.js"></script>
        <script src="./theme/highlight.css"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
